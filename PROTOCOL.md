# Sentra Agent 协议与数据流

本文件用于解释 Sentra Agent 为什么“更稳”、为什么“工具能跑起来”，以及一条消息从进入到最终发出去，中间到底发生了什么。

注意：这里讲的是“约束与数据流”的思想，而不是写给人手工拼格式的协议手册。你不需要记住任何标签细节也能用好 Sentra。

---

## 你只需要记住三件事

- **模型负责表达意图**：它要么给出最终回复，要么给出“我需要用哪些工具”。
- **系统负责可执行**：工具怎么调用、结果怎么回填、失败怎么重试/降级，都由框架兜底。
- **最终一定要回到“可发送的回复”**：无论中间工具跑了多少步，最后对用户只呈现自然的聊天内容。

---

## 统一输出约束（为什么不容易“说人话但系统无法执行”）

Sentra 将模型输出分成两类，并对其做严格治理：

1) **工具意图（Tool Intent）**
- 模型表达“我需要调用工具 X，并给出参数”。
- 系统会做：参数校验、执行、结果结构化回填、错误治理。

2) **最终回复（Final Reply）**
- 模型表达“发给用户看的内容”，可以包含文本与可选资源。
- 系统会做：输出预处理、格式校验、必要时修复/重试、发送队列去重/融合。

这样做的目的，是把“模型输出不稳定”的风险，尽可能收敛在框架层。

---

## 一次任务的典型数据流

用一句话总结：

> 收到消息 → 聚合 → 门禁 → 需要就用工具 → 汇总结果 → 生成最终回复 → 排队发出 → 写入历史与记忆。

其中关键点：

- **聚合**：把用户短时间连续输入合并成“本轮最终问题”，减少来回打断。
- **门禁**：群聊里不是每句话都要插话，系统会判断是否值得回复。
- **工具执行**：模型只说“想用什么工具”，系统保证“能执行、可追踪、可取消”。
- **发送治理**：避免群里刷屏、避免多任务完成导致消息交错、必要时做融合。

---

## 群聊为什么不容易串线

群聊里最容易翻车的是：A 问问题，B 插话，机器人把 A 的上下文拿去回答 B。

Sentra 的策略是：

- **同群不同人当成不同会话**：每个发送者都有自己的“处理槽位”。
- **中间过程先隔离**：某些中间输出（例如工具执行前的预回复）先进入该用户的临时区。
- **任务落地后再合并**：任务结束后再把该用户的临时区合并进群共享历史，避免污染。

---

## 高级细节

<details>
<summary>展开：实现层的结构化块（给想深入排障/二次开发的人）</summary>

Sentra 在内部会使用结构化文本块来表达：

- 用户问题（User Question）：用于让模型明确“这次要解决什么”。
- 工具意图（Tool Intent）：用于让系统可靠地提取工具名与参数。
- 工具结果（Tool Result）：由系统回填，作为只读证据提供给模型。
- 最终回复（Final Reply）：用于稳定地提取要发送的文本段落与资源。

并且在输出层做：预处理（去掉多余包裹）、校验、重试、必要时修复。

</details>
