# 日志级别：DEBUG | INFO | WARN | ERROR
LOG_LEVEL=DEBUG

# QQ OneBot 协议服务器地址
WS_HOST=localhost

# QQ OneBot 协议服务器端口
WS_PORT=6702

# WebSocket 请求超时时间（毫秒）
WS_TIMEOUT=60000

# NapCat SDK RPC 调用结果等待超时时间（毫秒）
SEND_RPC_TIMEOUT_MS=120000

# NapCat SDK RPC 超时重试次数（仅网络超时重试，不重试业务失败）
SEND_RPC_MAX_RETRIES=0

# WebSocket 重连间隔（毫秒）
WS_RECONNECT_INTERVAL_MS=10000

# WebSocket 最大重连次数
WS_MAX_RECONNECT_ATTEMPTS=60

# Agent 角色预设文件名称（存放在 agent-presets 目录下）
AGENT_PRESET_FILE=default.txt

# 轻量模型：将 .txt/.md 形式的 Agent 预设转换为结构化 JSON 角色卡（留空则使用主模型）
AGENT_PRESET_CONVERTER_MODEL=

# 是否启用教导模式（仅白名单用户可通过对话动态修改角色预设）
AGENT_PRESET_TEACHING_ENABLED=false

# 教导白名单（逗号分隔 QQ ID，* 表示所有用户）
AGENT_PRESET_TEACHING_WHITELIST=

# 教导模型（留空则复用 MAIN_AI_MODEL）
AGENT_PRESET_TEACHING_MODEL=

# 教导日志文件路径
AGENT_PRESET_TEACHING_LOG_FILE=./logs/preset-teaching.log

# 教导分析时附加的最近对话对数量（每对 = 1 user + 1 assistant）
AGENT_PRESET_TEACHING_CONTEXT_PAIRS=3

# OpenAI 兼容 API 基础地址
API_BASE_URL=https://yuanplus.chat/v1

# API 密钥
API_KEY=your_api_key_here

# 主要 AI 模型（用于所有对话场景）
MAIN_AI_MODEL=gemini-2.5-pro

# 主动 Planner 专用模型配置
PROACTIVE_DIRECTIVE_MODEL=gemini-flash-latest

# 主动 Planner 使用的温度
PROACTIVE_DIRECTIVE_TEMPERATURE=1

# 主动 Planner 最大token
PROACTIVE_DIRECTIVE_MAX_TOKENS=-1

# 主动 Planner 超时时间
PROACTIVE_DIRECTIVE_TIMEOUT=60000

# 主动 Planner 重试次数
PROACTIVE_DIRECTIVE_MAX_RETRIES=3

# Temperature（建议 0.5-0.8）
TEMPERATURE=0.7

# 最大 token 数（-1 表示不限制）
MAX_TOKENS=-1

# 最大重试次数（网络错误时）
MAX_RETRIES=3

# 请求超时时间（毫秒）
TIMEOUT=60000

# 是否启用 Redis
REDIS_ENABLED=true

# Redis 主机地址
REDIS_HOST=127.0.0.1

# Redis 端口
REDIS_PORT=6379

# Redis 数据库编号（0-15）
REDIS_DB=0

# Redis 密码（无密码可留空）
REDIS_PASSWORD=

# 私聊会话历史 key 前缀
REDIS_CONV_PRIVATE_PREFIX=sentra:conv:private:

# 群聊会话历史 key 前缀
REDIS_CONV_GROUP_PREFIX=sentra:conv:group:

# 会话历史过期时间（秒，0 表示不过期）
REDIS_CONV_TTL_SECONDS=86400

# 单个会话最大保留消息条数（0 表示不限制）
REDIS_CONV_MAX_MESSAGES=0

# 群聊历史 key 前缀
REDIS_GROUP_HISTORY_PREFIX=sentra:group:

# 群聊历史过期时间（秒，0 表示不过期）
REDIS_GROUP_HISTORY_TTL_SECONDS=0

# 是否启用主动回复调度器
DESIRE_ENABLED=true

# 主动调度状态 key 前缀（用于 Redis）
REDIS_DESIRE_PREFIX=sentra:desire:

# 主动调度状态过期时间（秒，0 表示不过期）
DESIRE_TTL_SECONDS=86400

# 全局心跳间隔（毫秒），用于周期性检查是否需要尝试主动发言
DESIRE_TICK_INTERVAL_MS=60000

# 群聊冷场阈值（秒，距上次机器人发言多久才允许考虑主动开口）
DESIRE_GROUP_SILENT_SEC=180

# 私聊冷场阈值（秒）
DESIRE_PRIVATE_SILENT_SEC=120

# 群聊最小用户静默时间（秒，用作概率曲线的参考尺度，而非硬门槛）
DESIRE_GROUP_MIN_SINCE_USER_SEC=180

# 私聊最小用户静默时间（秒，用作概率曲线的参考尺度，而非硬门槛）
DESIRE_PRIVATE_MIN_SINCE_USER_SEC=180

# 同一会话每小时最多主动发言次数（期望值上限，不是硬性每小时必发）
DESIRE_MAX_PROACTIVE_PER_HOUR=2

# 同一会话每天最多主动发言次数（0 表示不限制每日上限，仅按每小时上限控制）
DESIRE_MAX_PROACTIVE_PER_DAY=0

# 主动触发强度系数（>1 更积极，<1 更克制，建议 0.5~2）
DESIRE_PROACTIVE_INTENSITY=1.0

# 消息频率统计窗口（秒）
DESIRE_MSG_WINDOW_SEC=180

# 群聊窗口内最大消息数（超过则禁止主动发言）
DESIRE_GROUP_MAX_MSG_PER_WINDOW=12

# 私聊窗口内最大消息数
DESIRE_PRIVATE_MAX_MSG_PER_WINDOW=12

# 主动回复活跃时间段开始时刻（本地小时 0-23）
DESIRE_ACTIVE_HOUR_START=6

# 主动回复活跃时间段结束时刻
DESIRE_ACTIVE_HOUR_END=23

# 同一会话两次主动发言之间的最小间隔（秒，硬冷却；0 表示不限制，仅依赖概率和频控）
DESIRE_MIN_INTERVAL_BETWEEN_PROACTIVE_SEC=300

# 是否启用主动回复的用户疲劳反馈；关闭时不会对忽视主动的用户施加概率惩罚
DESIRE_USER_FATIGUE_ENABLED=true

# 若在该窗口内用户没有新消息，则记为一次“未回应 episode”，用于累积 strikes。
DESIRE_USER_FATIGUE_RESPONSE_WINDOW_SEC=300

# 连续多少次未在窗口内回应后，进入疲劳惩罚期（至少为 1）
DESIRE_USER_FATIGUE_MAX_STRIKES=3

# 进入疲劳惩罚期后的概率折扣因子（0-1，建议 0.1~0.5；0.2 表示主动概率打 2 折）
DESIRE_USER_FATIGUE_PENALTY_FACTOR=0.2

# 疲劳惩罚持续时间（秒）。在此期间若仍持续未回应，会延长惩罚结束时间。
DESIRE_USER_FATIGUE_PENALTY_DURATION_SEC=3600

# 用户疲劳状态在 Redis 中的 TTL（秒，0 表示不过期）。
DESIRE_USER_FATIGUE_TTL_SECONDS=86400

# 用户疲劳状态使用的 Redis key 前缀
REDIS_DESIRE_USER_FATIGUE_PREFIX=sentra:desire:user:

# 是否启用格式修复（不合规时自动修复）
ENABLE_FORMAT_REPAIR=true

# 格式修复使用的模型
REPAIR_AI_MODEL=gemini-flash-latest

# Bot 名称列表（逗号分隔，用作唤醒关键词和回复概率增强）
BOT_NAMES=失语

# 显式 @ 是否必须回复（true=一律回复，false=交给模型决定）
MENTION_MUST_REPLY=false

# 是否启用基于 LLM 的群聊回复决策
ENABLE_REPLY_INTERVENTION=true

# 群聊回复决策模型
REPLY_DECISION_MODEL=grok-beta

# 群聊回复决策最大 token 数（-1 表示不限制）
REPLY_DECISION_MAX_TOKENS=-1

# 群聊回复决策最大重试次数
REPLY_DECISION_MAX_RETRIES=3

# 群聊回复决策超时时间（毫秒）
REPLY_DECISION_TIMEOUT=15000

# 群聊回复决策使用的群历史消息条数
REPLY_DECISION_GROUP_RECENT_MESSAGES=15

# 群聊回复决策使用的发送者历史消息条数
REPLY_DECISION_SENDER_RECENT_MESSAGES=5

# 群聊回复决策上下文最大字符数
REPLY_DECISION_CONTEXT_MAX_CHARS=120

# 是否启用本地 ReplyGate 价值过滤（false=完全交给 ReplyIntervention）
REPLY_GATE_ENABLED=true

# 概率低于该值视为噪声，不参与累积（0-1）
REPLY_GATE_ACCUM_BASELINE=0.1

# 单个群+用户在有效时间内累积达到该阈值
REPLY_GATE_ACCUM_THRESHOLD=1.0

# 累积值的时间半衰期（毫秒），越小衰减越快
REPLY_GATE_ACCUM_HALFLIFE_MS=180000

# 是否启用群聊注意力窗口功能
ATTENTION_WINDOW_ENABLED=true

# 群聊注意力窗口时间（毫秒）
ATTENTION_WINDOW_MS=120000

# 群聊注意力窗口最大发送者数量
ATTENTION_MAX_SENDERS=3

# 是否启用用户疲劳度控制
USER_FATIGUE_ENABLED=true

# 用户疲劳度统计窗口（毫秒）
USER_REPLY_WINDOW_MS=300000

# 用户基础回复次数限制
USER_REPLY_BASE_LIMIT=5

# 用户最小回复间隔（毫秒）
USER_REPLY_MIN_INTERVAL_MS=10000

# 用户疲劳度回退因子
USER_REPLY_BACKOFF_FACTOR=2

# 用户最大回退倍数
USER_REPLY_MAX_BACKOFF_MULTIPLIER=8

# 是否启用群组疲劳度控制
GROUP_FATIGUE_ENABLED=true

# 群组疲劳度统计窗口（毫秒）
GROUP_REPLY_WINDOW_MS=300000

# 群组基础回复次数限制
GROUP_REPLY_BASE_LIMIT=30

# 群组最小回复间隔（毫秒）
GROUP_REPLY_MIN_INTERVAL_MS=2000

# 群组疲劳度回退因子
GROUP_REPLY_BACKOFF_FACTOR=2

# 群组最大回退倍数
GROUP_REPLY_MAX_BACKOFF_MULTIPLIER=8

# 每个发送方的最大并发任务数（推荐 1，避免多次回复冲突）
MAX_CONCURRENT_PER_SENDER=1

# 排队任务超时时间（毫秒，超过则丢弃）
QUEUE_TIMEOUT=30000

# 消息聚合窗口（毫秒，第一条触发后等待此时间看是否有更多消息）
BUNDLE_WINDOW_MS=5000

# 消息聚合最大等待时间（毫秒）
BUNDLE_MAX_MS=15000

# 向量模型名称（用于语义聚合）
EMBEDDING_MODEL=text-embedding-3-small

# 向量模型 API 密钥（留空则复用 API_KEY）
EMBEDDING_API_KEY=

# 向量模型 API 地址（留空则复用 API_BASE_URL）
EMBEDDING_API_BASE_URL=

# 继续视为同一轮输入的最小语义相似度（0-1）
BUNDLE_MIN_SIMILARITY=0.6

# 连续低相似度多少次后视为新话题
BUNDLE_MAX_LOW_SIM_COUNT=2

# 语义聚合使用的向量相似度计算最大超时时间（毫秒）：
BUNDLE_EMBEDDING_TIMEOUT_MS=8000

# 语义聚合 Embedding 失败时的最大重试次数：
BUNDLE_EMBEDDING_MAX_RETRIES=0

# 群聊多用户合并开关（在短时间内将多人的提问合并为一次回复）
GROUP_MULTI_USER_MERGE_ENABLED=true

# 群聊多用户合并窗口（毫秒，从第一个触发回复的用户开始计时）
GROUP_MULTI_USER_MERGE_WINDOW_MS=10000

# 每次合并最多包含的不同用户数量（2 表示最多合并两个人的问题一起回复）
GROUP_MULTI_USER_MERGE_MAX_USERS=2

# 纯文本连续回复优化：同一会话连续多少条无工具调用回复时仅保留最新一条（0 表示关闭）
PURE_REPLY_SKIP_THRESHOLD=3

# 纯文本连续回复优化冷却时间（毫秒）
PURE_REPLY_SKIP_COOLDOWN_MS=300000

# 是否启用“补充消息单次吞吐”策略（Judge / ToolResult 阶段）：
SWALLOW_ON_SUPPLEMENT_ENABLED=true

# “补充消息单次吞吐”在 Judge / ToolResult 阶段的最大静默等待时间（毫秒）：
SWALLOW_ON_SUPPLEMENT_MAX_WAIT_MS=0

# 是否启用最近发送去重（跨批次/跨轮）
SEND_RECENT_DEDUP_ENABLED=true

# 最近发送窗口时长（毫秒）
SEND_RECENT_DEDUP_TTL_MS=600000

# 每个会话最多保留多少条已发送文本参与去重
SEND_RECENT_DEDUP_MAX_PER_GROUP=20

# 是否对私聊启用严格语义去重（true=语义相似度，false=仅文本匹配）
SEND_RECENT_DEDUP_STRICT_FOR_PRIVATE=true

# 发送去重判定为高度相似的语义相似度阈值（0-1）
SEND_DEDUP_MIN_SIMILARITY=0.8

# 是否在相似度灰区时调用 LLM 精判（false=仅用 Embedding）
SEND_DEDUP_USE_LLM=false

# 是否输出本地相似度判定的调试日志
SEND_DEDUP_LOCAL_DEBUG=false

# 回复发送间隔（毫秒，多个任务同时完成时的发送延迟）
REPLY_SEND_DELAY_MS=2000

# 每个群最多保存的对话对数量（1 对 = 1 user + 1 assistant）
MAX_CONVERSATION_PAIRS=20

# MCP 上下文中每个群最多使用的历史对话对数量（不设置则等于 MAX_CONVERSATION_PAIRS）
MCP_MAX_CONTEXT_PAIRS=20

# ===== 上下文压缩与记忆配置 =====
# 是否启用旧对话自动摘要与长期记忆
CONTEXT_MEMORY_ENABLED=true

# 用于摘要的模型（留空则复用 MAIN_AI_MODEL）
CONTEXT_MEMORY_MODEL=

# 被丢弃的对话对累计达到多少组时触发一次摘要（0=自动取 MCP_MAX_CONTEXT_PAIRS / 2）
CONTEXT_MEMORY_TRIGGER_DISCARDED_PAIRS=0

# 上下文摘要 key 前缀
REDIS_CONTEXT_MEMORY_PREFIX=sentra:memory:

# 摘要过期时间（秒，0 表示不过期）
REDIS_CONTEXT_MEMORY_TTL_SECONDS=0

# 摘要时间范围描述使用的时区
CONTEXT_MEMORY_TIMEZONE=Asia/Shanghai

# 最大重试次数（格式验证失败或 Token 超限时）
MAX_RESPONSE_RETRIES=3

# 响应文本 token 上限（只统计 <text*> 段，0 或 -1 表示不限制）
MAX_RESPONSE_TOKENS=260

# Token 计数使用的模型名称
TOKEN_COUNT_MODEL=gemini-flash-latest

# 是否启用严格格式验证
ENABLE_STRICT_FORMAT_CHECK=true

# Sentra-Emo 服务地址
SENTRA_EMO_URL=http://localhost:7200

# Sentra-Emo 请求超时时间（毫秒）
SENTRA_EMO_TIMEOUT=60000

# ===== 用户画像配置 =====
# 是否启用用户画像功能
ENABLE_USER_PERSONA=true

# 画像更新时间间隔（毫秒，防止频繁调用 LLM）
PERSONA_UPDATE_INTERVAL_MS=600000

# 画像更新消息阈值（距上次更新至少需要积累的新消息数）
PERSONA_MIN_MESSAGES=30

# 用户数据存储目录（相对于项目根目录）
PERSONA_DATA_DIR=./userData

# 画像分析使用的模型
PERSONA_MODEL=grok-beta

# 最大历史消息保留数
PERSONA_MAX_HISTORY=100

# 最近消息分析窗口（条数，用于画像更新时的证据采样）
PERSONA_RECENT_MESSAGES=40

# 画像元素半衰期（毫秒，控制旧特征随时间衰减速度）
PERSONA_HALFLIFE_MS=172800000

# 性格特征最大数量
PERSONA_MAX_TRAITS=6

# 兴趣领域最大数量
PERSONA_MAX_INTERESTS=8

# 行为模式最大数量
PERSONA_MAX_PATTERNS=6

# 关键洞察最大数量
PERSONA_MAX_INSIGHTS=6

# ===== NapCat 安装配置 =====
# 是否跳过 NapCat 自动安装提示（已手动安装时设为 true）
SENTRA_SKIP_NAPCAT_INSTALL=false

# NapCat 安装文件存放目录（默认写到项目同级 napcat-installer）
NAPCAT_INSTALL_DIR=..

# NapCat Linux Shell 安装脚本下载地址（留空则使用官方镜像）
NAPCAT_INSTALLER_URL=